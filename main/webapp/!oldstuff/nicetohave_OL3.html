<!DOCTYPE html>
<html>
<head>
    <title></title>
	<meta charset="utf-8" />
</head>
<body>

</body>
</html>
				//$.ajax({
				//	cache: false,
				//	type: "POST",
				//	crossDomain: true,
				//	url: "http://sejlrute.dmi.dk/SejlRute/SR",
				//	data: "req=" + request,
				//	dataType: "text",
				//	crossDomain: true,
				//	timeout: 10000, //error after timeout
				//	success: function (data) {
				//		data = JSON.parse(data);
				//		if (data.error == 9) {
				//			console.log("Communication error with weather service:", data.errorMsg, " - Probably a bad request.");
				//		} else {
				//			weatherDataCleaner(data, GPSLocation, weathertype);
				//		}
				//	},
				//	error: function (xhr, ajaxOptions, thrownError) {
				//		if (thrownError === 'timeout') {
				//			console.log('WEATHER SERVICE TIMEOUT!')
				//		} else {
				//			console.log("Communication error with weather service:'", thrownError, "' - Probably due to no 'Access-Control-Allow-Origin' in header of resource.\nPlease use Chrome plugin: https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi/related?hl=en-US - Rob - the developer.");
				//		}
				//	},
				//});



		//Generates an URL to request weather data from provider
		//generateWeatherRequestURL = function (type, coordinate, projectedtime, projectedtimeETA) {
		//	var URI = "{'mssi': 999999999, 'datatypes': ['sealevel', 'current', 'wave', 'wind', 'density'], 'dt': 15, 'waypoints': [{ 'eta': '";
		//	var now = new Date(), now2 = new Date();
		//	//now.setTime(now.getTime() + (1000 * 60 * 60) * (2));
		//	now2.setTime(now2.getTime() + 10000);


		//	function rendertimeformat(time) {
		//		return time.toISOString().substring(0, now.toISOString().length - 4) + "000+0000";
		//	}

		//	if (type == 'weatherShipActual') { //gets weather for current location, current time
		//		var spoofCoord = (coordinate[0] + 0.0001); //add a second to the coords to make sure the service doesnt throw error
		//		URI += rendertimeformat(now) + "','heading': 'RL', 'lat':" + coordinate[0] + ", 'lon':" + coordinate[1] + "},{'eta': '";
		//		URI += rendertimeformat(now2) + "','heading': 'RL', 'lat':" + spoofCoord + ", 'lon':" + coordinate[1] + "}]}";
		//		return URLencode(URI);
		//	} else if (type == 'weatherLocationProjected') {
		//		//var newnowStr = "";
		//		//for (var i = 0; i != route.sheduleElement.length - 1; i++) {
		//		//	now.setTime(now.getTime() + (1000 * 60 * 60) * (2)); //add one hour ((milli * sec * min) * hour = hours)
		//		//	newnowStr = now.toISOString().substring(0, now.toISOString().length - 4) + "000+0000";
		//		//	console.log(newnowStr);
		//		//	route.sheduleElement[i].eta = newnowStr;
		//		//}
		//	}
		//}






		//mapSource.getFeatureById(featureid).getStyle().getText().setText('' + newOffsetX);



//find map element in case need to fix touc zoom pinch bug.
			//$("li.item-ii").find("li").css("background-color", "red");
			//$('#map .ol-unselectable').first().addClass('BOOP');
			//var mapcan = $('#map .ol-unselectable').first();
			//$('#map').$('canvas')[0].addClass('YOLO');
			//$('#map').find(".ol-viewport .ol-touch  canvas .ol-unselectable").addClass('BOOP');



		//MOUSEPOSITION CONTROL - used for debugging - adds a control to the map
		var mousePositionControl = new ol.control.MousePosition({
			coordinateFormat: ol.coordinate.createStringXY(2),
			projection: 'EPSG:4326', //'EPSG:3857'
			// comment the following two lines to have the mouse position
			// be placed within the map.
			//className: 'custom-mouse-position',
			//target: document.getElementById('mouse-position'),
			undefinedHTML: '&nbsp;'
		});
		map.addControl(mousePositionControl);




		////Place testmarker for icontest


		//var mapVectorSource = new ol.source.Vector({
		//	features: []
		//});
		//var mapVectorLayer = new ol.layer.Vector({
		//	source: mapVectorSource
		//});

		//map.addLayer(mapVectorLayer);
		//function createMarker(location, style) {
		//	var iconFeature = new ol.Feature({
		//		geometry: new ol.geom.Point(location)
		//	});
		//	iconFeature.setStyle(style);

		//	return iconFeature
		//}
		//iconStyle = new ol.style.Style({
		//	image: new ol.style.Icon(/** @type {olx.style.IconOptions} */({
		//		anchor: [0.5, 1],
		//		anchorXUnits: 'fraction',
		//		anchorYUnits: 'fraction',
		//		src: 'circle-icon-25.png',
		//		scale:0.2
		//	}))
		//});
		//var marker = createMarker(ol.proj.transform([38, 50], 'EPSG:4326', 'EPSG:3857'), iconStyle);
		//mapVectorSource.addFeature(marker);





//ADDS A VECTOR TO A LAYER
		var generateWaveTriangle = function () {//consists of 4 triangles
			function createtriangle1() {
				var ret = [];
					var tmparr = [];

					tmparr.push(13);
					tmparr.push(55);
					ret.push(tmparr);

					var tmparr = [];
					tmparr.push(12);
					tmparr.push(55);
					ret.push(tmparr);

					var tmparr = [];
					tmparr.push(12);
					tmparr.push(54);
					ret.push(tmparr);

					var tmparr = [];
					tmparr.push(13);
					tmparr.push(55);
					ret.push(tmparr);

					return ret
			}
			var coords = createtriangle1();
			console.log(coords);
			var lineString = new ol.geom.LineString(coords);
			lineString.transform('EPSG:4326', 'EPSG:3857'); //transform to EPSG:3857
			var feature = new ol.Feature({ // create the feature
				geometry: lineString,
				name: 'wavetriangle1',
			});
			feature.setId("wavetriangle1");
			feature.setStyle(WORMstyle('wavetriangle1'));
			//console.log(lineString);


			return [feature];

		}














				//weatherpattern generator for fake data
		var weatherWindSpeedMaxInc = 5; //so doesn't go overboard. (factor 10 for accuracy)
		var weatherPattern =[]// = matrix(50,30); //fake weather data object for map area around route

		var weatherPosGen = function () {
			return weatherData;
		}
		//var weatherPattern = { //fake weather data object for map area around route
		//	positions: []
		//}

		//push data into weatherPattern
		var weatherLastWindSpeedLat = 0; //remembers last windspeed so it doesnt get too far out of hand, is cleared every 100 lat runs of weatherPosGen
		for (var y = 0; y != 50; y++) {
			var tmpwindspeed = getRandomInt(parseInt(weatherLastWindSpeedLat), parseInt(weatherWindSpeedMaxInc));
			weatherLastWindSpeedLat = parseInt(weatherLastWindSpeedLat) + parseInt(tmpwindspeed);

			var tmppattern = [];
			var ipos = 0;
			for (var i = 0; i != 30; i++) { //50lat* 30lon positions = 1500 positions
				tmppattern.push({ id: i, ws: (tmpwindspeed)});

			}
			weatherPattern[y] = (tmppattern); //add to array

		}
		console.log("weatherPattern:", weatherPattern);

		var weatherPatternOnPosition = function () { //returns billiniar interpolation value of specific point at 100//100 resolution

		}
		//END weatherpattern generator for fake data

		if (1 == 1) {
			$("#popup").css('position', 'relative')
			$("#popup").css('left', '10px')
			$("#popup").css('top', '0px')
			$("#popup").css('width', '100')
			$("#popup").css('height', '60')
			$("#popup").css('background-color', '#eeeeee')
			$("#popup").css('z-order', '9999')



			for (var y = 0; y != weatherPattern.length; y++) {
				for (var x = 0; x != weatherPattern[0].length; x++) {

					//var col = weatherPattern.positions;
					$("#popup").append("<div style='position:absolute;left:" + (y + y) + "px;top:" + (x + x) + "px;width:2px;height:2px;background-color:rgba(" + weatherPattern[y][x].ws + ", 0, 0, 1)'>&nbsp;</div>")
				}
			}
			console.log(weatherPattern[0].length)
		}



















		Stuff for detecting zooming and pinching - didnt fix the browser issues with zooming. Uses hammer.js
<script src="scripts/hammer-time.min.js"></script>



			//$('#containerDiv').on('touchstart', function (e) {
			//	console.log(e)
			//	try{
			//		if (!$('#containerDiv').hasClass("hide") && e.originalEvent.touches.length > 1) {
			//			console.log(e.originalEvent.touches.length)
			//			e.stopPropagation();
			//			setTimeout(function(){ $('#containerDiv').addClass('hide'); }, 1000);
			//		}
			//	} catch (touchlengthexception) {
			//		console.log("toucherror");
			//	}
			//});


			////Disable pinch and rotate gestures while displaying popup messages - so user does not overzoom and cannot return to map
			//var mc = new Hammer.Manager(document.getElementById('containerDiv'));
			//var pinch = new Hammer.Pinch();
			//var rotate = new Hammer.Rotate();
			//pinch.recognizeWith(rotate);
			//mc.add([pinch, rotate]);
			//mc.on("pinch rotate", function (ev) {
			//	$('#containerDiv').removeClass('hide');

			//	/*Do nothing while displaying popup overlay*/
			//});
